# 面试题整理

## 一、某大型厂商

### HashMap原理

**HashMap的工作原理**

HashMap的工作原理 ：HashMap是基于散列法（又称哈希法）的原理，使用put(key, value)存储对象到HashMap中，使用get(key)从HashMap中获取对象。当我们给put()方法传递键和值时，我们先对键调用hashCode()方法，返回的hashCode用于找到bucket（桶）位置来储存Entry对象。HashMap是在bucket中储存键对象和值对象，作为Map.Entry。并不是仅仅只在bucket中存储值。



### Set集合 实现原理

#### 说一下 HashSet 的实现原理？

HashSet 是基于 HashMap 实现的，HashSet的值存放于HashMap的key上，HashMap的value统一为PRESENT，因此 HashSet 的实现比较简单，相关 HashSet 的操作，基本上都是直接调用底层 HashMap 的相关方法来完成，HashSet 不允许重复的值。



### Mysql查重

按照 client_id 字段查重，查出 client_id 重复的字段的 id ：

```mysql
SELECT c.id
from client c
where c.client_id
in (
 SELECT c.client_id , COUNT(*)
 from client c
 group by c.client_id
 having COUNT(*) > 1
)
```



### synchronized 和 volatile 的区别是什么？

synchronized 表示只有一个线程可以获取作用对象的锁，执行代码，阻塞其他线程。

volatile 表示变量在 CPU 的寄存器中是不确定的，必须从主存中读取。保证多线程环境下变量的可见性；禁止指令重排序。

**区别**

- volatile 是变量修饰符；synchronized 可以修饰类、方法、变量。
- volatile 仅能实现变量的修改可见性，不能保证原子性；而 synchronized 则可以保证变量的修改可见性和原子性。
- volatile 不会造成线程的阻塞；synchronized 可能会造成线程的阻塞。
- volatile标记的变量不会被编译器优化；synchronized标记的变量可以被编译器优化。
- **volatile关键字**是线程同步的**轻量级实现**，所以**volatile性能肯定比synchronized关键字要好**。但是**volatile关键字只能用于变量而synchronized关键字可以修饰方法以及代码块**。synchronized关键字在JavaSE1.6之后进行了主要包括为了减少获得锁和释放锁带来的性能消耗而引入的偏向锁和轻量级锁以及其它各种优化之后执行效率有了显著提升，**实际开发中使用 synchronized 关键字的场景还是更多一些**。



### SQL优化

MySQL提供了explain命令来查看语句的执行计划

#### 大表数据查询，怎么优化

1. 优化shema、sql语句+索引；
2. 第二加缓存，memcached, redis；
3. 主从复制，读写分离；
4. 垂直拆分，根据你模块的耦合度，将一个大的系统分为多个小的系统，也就是分布式系统；
5. 水平切分，针对数据量大的表，这一步最麻烦，最能考验技术水平，要选择一个合理的sharding key, 为了有好的查询效率，表结构也要改动，做一定的冗余，应用也要改，sql中尽量带sharding key，将数据定位到限定的表上去查，而不是扫描全部的表；
6. 开启慢查询日志

#### 超大分页怎么处理？

```
推荐】利用延迟关联或者子查询优化超多分页场景。 
说明：MySQL并不是跳过offset行，而是取offset+N行，然后返回放弃前offset行，返回N行，那当offset特别大的时候，效率就非常的低下，要么控制返回的总页数，要么对超过特定阈值的页数进行SQL改写。  
正例：先快速定位需要获取的id段，然后再关联：  
SELECT a.* FROM 表1 a, (select id from 表1 where 条件 LIMIT 100000,20 ) b where a.id=b.id
```

#### 优化查询过程中的数据访问

- 访问数据太多导致查询性能下降
- 确定应用程序是否在检索大量超过需要的数据，可能是太多行或列
- 确认MySQL服务器是否在分析大量不必要的数据行
- 避免犯如下SQL语句错误
- 查询不需要的数据。解决办法：使用limit解决
- 多表关联返回全部列。解决办法：指定列名
- 总是返回全部列。解决办法：避免使用SELECT *
- 重复查询相同的数据。解决办法：可以缓存数据，下次直接读取缓存
- 是否在扫描额外的记录。解决办法：
- 使用explain进行分析，如果发现查询需要扫描大量的数据，但只返回少数的行，可以通过如下技巧去优化：
- 使用索引覆盖扫描，把所有的列都放到索引中，这样存储引擎不需要回表获取对应行就可以返回结果。
- 改变数据库和表的结构，修改数据表范式
- 重写SQL语句，让优化器可以以更优的方式执行查询。



### Spring AOP 原理剖析

​		AOP 代理其实是由 AOP 框架动态生成的一个对象，该对象可作为目标对象使用。AOP 代理包含了目标对象的全部方法，但 AOP 代理中的方法与目标对象的方法存在差异：AOP 方法在特定切入点添加了增强处理，并回调了目标对象的方法。

​		Spring 的 AOP 代理由 Spring 的 IoC 容器负责生成、管理，其依赖关系也由 IoC 容器负责管理。因此，AOP 代理可以直接使用容器中的其他 Bean 实例作为目标，这种关系可由 IoC 容器的依赖注入提供。

​		AOP 框架负责动态地生成 AOP 代理类，这个代理类的方法则由 Advice 和回调目标对象的方法所组成。



### 自定义注解

#### **元注解：**

　　元注解的作用就是负责注解其他注解。Java5.0定义了4个标准的meta-annotation类型，它们被用来提供对其它 annotation类型作说明。Java5.0定义的元注解：
　　　　1.@Target,
　　　　2.@Retention,
　　　　3.@Documented,
　　　　4.@Inherited

#### **@Target：**

　　　@Target说明了Annotation所修饰的对象范围：Annotation可被用于 packages、types（类、接口、枚举、Annotation类型）、类型成员（方法、构造方法、成员变量、枚举值）、方法参数和本地变量（如循环变量、catch参数）。在Annotation类型的声明中使用了target可更加明晰其修饰的目标。

**作用：用于描述注解的使用范围（即：被描述的注解可以用在什么地方）**

　　**取值(ElementType)有：**

　　　　1.CONSTRUCTOR:用于描述构造器
　　　　2.FIELD:用于描述域
　　　　3.LOCAL_VARIABLE:用于描述局部变量
　　　　4.METHOD:用于描述方法
　　　　5.PACKAGE:用于描述包
　　　　6.PARAMETER:用于描述参数
　　　　7.TYPE:用于描述类、接口(包括注解类型) 或enum声明

#### **@Retention：**

　　**@Retention**定义了该Annotation被保留的时间长短：某些Annotation仅出现在源代码中，而被编译器丢弃；而另一些却被编译在class文件中；编译在class文件中的Annotation可能会被虚拟机忽略，而另一些在class被装载时将被读取（请注意并不影响class的执行，因为Annotation与class在使用上是被分离的）。使用这个meta-Annotation可以对 Annotation的“生命周期”限制。

　　**作用：表示需要在什么级别保存该注释信息，用于描述注解的生命周期（即：被描述的注解在什么范围内有效）**

　　**取值（RetentionPoicy）有：**

　　　　1.SOURCE:在源文件中有效（即源文件保留）
　　　　2.CLASS:在class文件中有效（即class保留）
　　　　3.RUNTIME:在运行时有效（即运行时保留）

#### **@Documented:**

　　***\*@\****Documented用于描述其它类型的annotation应该被作为被标注的程序成员的公共API，因此可以被例如javadoc此类的工具文档化。Documented是一个标记注解，没有成员。

#### **@Inherited：**

　　@Inherited 元注解是一个标记注解，@Inherited阐述了某个被标注的类型是被继承的。如果一个使用了@Inherited修饰的annotation类型被用于一个class，则这个annotation将被用于该class的子类。

　　注意：@Inherited annotation类型是被标注过的class的子类所继承。类并不从它所实现的接口继承annotation，方法并不从它所重载的方法继承annotation。

　　当@Inherited annotation类型标注的annotation的Retention是RetentionPolicy.RUNTIME，则反射API增强了这种继承性。如果我们使用java.lang.reflect去查询一个@Inherited annotation类型的annotation时，反射代码检查将展开工作：检查class和其父类，直到发现指定的annotation类型被发现，或者到达类继承结构的顶层。

#### **自定义注解：**

　　使用@interface自定义注解时，自动继承了java.lang.annotation.Annotation接口，由编译程序自动完成其他细节。在定义注解时，不能继承其他的注解或接口。@interface用来声明一个注解，其中的每一个方法实际上是声明了一个配置参数。方法的名称就是参数的名称，返回值类型就是参数的类型（返回值类型只能是基本类型、Class、String、enum）。可以通过default来声明参数的默认值。

　　**定义注解格式：**
　　public @interface 注解名 {定义体}

```java
@Target(ElementType.METHOD)     // 这个注解是用来规定注解的作用范围的,这里定义为method方法级别.
@Retention(RetentionPolicy.RUNTIME)    // 这个注解可以理解为定义注解的生命周期,这里标识一直存在(编译和运行之后)
public @interface LogAnnotation {
    // 定义注解参数
    public String operateContent() default "";

    public String operateType() default "";
}
```

### Spring 循环调用解决办法

（一）对象循环依赖

（1）循环依赖-->循环引用。--->即2个或以上bean 互相持有对方，最终形成闭环。

​		  eg：A依赖B，B依赖C，C又依赖A。【注意：这里不是函数的循环调用【是个死循环，除非有终结条件】，是对象相互依赖关系

（2）循环依赖的场景？

​		①构造器依赖（这个解决不了，具体原因往下看）。

​		②通过setter循环依赖。（这个可以解决）。

（3） 如何发现？

​		spring在创建对象之前（对象还未出现）的时候，会将放在一个Set容器里，beanName为key，表示该对象正在被创建中。

4.如何解决？

​		之前说到构造器依赖的时候，ABC创建失败的原因是因为A创建对象需要B，B创建对象需要C，C创建对象需要A，这个需求是在ABC都还未创建就彼此需要，彼此发现对象都不存在，所以才被抛出异常。

​		如但是通过setter的循环依赖，可以避免这个错误。

​		spring将单例bean的存放利用三个hashmap作为三个级别的缓存解决循环引用问题。

### Nginx负载均衡方式

负载均衡算法

- **源地址哈希法**：根据获取客户端的IP地址，通过哈希函数计算得到一个数值，用该数值对服务器列表的大小进行取模运算，得到的结果便是客服端要访问服务器的序号。采用源地址哈希法进行负载均衡，同一IP地址的客户端，当后端服务器列表不变时，它每次都会映射到同一台后端服务器进行访问。
- **轮询法**：将请求按顺序轮流地分配到后端服务器上，它均衡地对待后端的每一台服务器，而不关心服务器实际的连接数和当前的系统负载。
- **随机法**：通过系统的随机算法，根据后端服务器的列表大小值来随机选取其中的一台服务器进行访问。
- **加权轮询法**：不同的后端服务器可能机器的配置和当前系统的负载并不相同，因此它们的抗压能力也不相同。给配置高、负载低的机器配置更高的权重，让其处理更多的请；而配置低、负载高的机器，给其分配较低的权重，降低其系统负载，加权轮询能很好地处理这一问题，并将请求顺序且按照权重分配到后端。
- **加权随机法**：与加权轮询法一样，加权随机法也根据后端机器的配置，系统的负载分配不同的权重。不同的是，它是按照权重随机请求后端服务器，而非顺序。
- **最小连接数法**：由于后端服务器的配置不尽相同，对于请求的处理有快有慢，最小连接数法根据后端服务器当前的连接情况，动态地选取其中当前积压连接数最少的一台服务器来处理当前的请求，尽可能地提高后端服务的利用效率，将负责合理地分流到每一台服务器。



### Redis使用

#### 数据类型

Redis主要有5种数据类型，包括String，List，Set，Zset，Hash，满足大部分的使用要求

| 数据类型 | 可以存储的值           | 操作                                                         | 应用场景                                                     |
| -------- | ---------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| STRING   | 字符串、整数或者浮点数 | 对整个字符串或者字符串的其中一部分执行操作 对整数和浮点数执行自增或者自减操作 | 做简单的键值对缓存                                           |
| LIST     | 列表                   | 从两端压入或者弹出元素 对单个或者多个元素进行修剪， 只保留一个范围内的元素 | 存储一些列表型的数据结构，类似粉丝列表、文章的评论列表之类的数据 |
| SET      | 无序集合               | 添加、获取、移除单个元素 检查一个元素是否存在于集合中 计算交集、并集、差集 从集合里面随机获取元素 | 交集、并集、差集的操作，比如交集，可以把两个人的粉丝列表整一个交集 |
| HASH     | 包含键值对的无序散列表 | 添加、获取、移除单个键值对 获取所有键值对 检查某个键是否存在 | 结构化的数据，比如一个对象                                   |
| ZSET     | 有序集合               | 添加、获取、删除元素 根据分值范围或者成员来获取元素 计算一个键的排名 | 去重但可以排序，如获取排名前几名的用户                       |

#### 缓存雪崩

**缓存雪崩**是指缓存同一时间大面积的失效，所以，后面的请求都会落到数据库上，造成数据库短时间内承受大量请求而崩掉。

**解决方案**

1. 缓存数据的过期时间设置随机，防止同一时间大量数据过期现象发生。
2. 一般并发量不是特别多的时候，使用最多的解决方案是加锁排队。
3. 给每一个缓存数据增加相应的缓存标记，记录缓存的是否失效，如果缓存标记失效，则更新数据缓存。

#### 缓存穿透

**缓存穿透**是指缓存和数据库中都没有的数据，导致所有的请求都落到数据库上，造成数据库短时间内承受大量请求而崩掉。

**解决方案**

1. 接口层增加校验，如用户鉴权校验，id做基础校验，id<=0的直接拦截；
2. 从缓存取不到的数据，在数据库中也没有取到，这时也可以将key-value对写为key-null，缓存有效时间可以设置短点，如30秒（设置太长会导致正常情况也没法使用）。这样可以防止攻击用户反复用同一个id暴力攻击
3. 采用布隆过滤器，将所有可能存在的数据哈希到一个足够大的 bitmap 中，一个一定不存在的数据会被这个 bitmap 拦截掉，从而避免了对底层存储系统的查询压力

**附加**

对于空间的利用到达了一种极致，那就是Bitmap和布隆过滤器(Bloom Filter)。
Bitmap： 典型的就是哈希表
缺点是，Bitmap对于每个元素只能记录1bit信息，如果还想完成额外的功能，恐怕只能靠牺牲更多的空间、时间来完成了。

布隆过滤器（推荐）

就是引入了k(k>1)k(k>1)个相互独立的哈希函数，保证在给定的空间、误判率下，完成元素判重的过程。
它的优点是空间效率和查询时间都远远超过一般的算法，缺点是有一定的误识别率和删除困难。
Bloom-Filter算法的核心思想就是利用多个不同的Hash函数来解决“冲突”。
Hash存在一个冲突（碰撞）的问题，用同一个Hash得到的两个URL的值有可能相同。为了减少冲突，我们可以多引入几个Hash，如果通过其中的一个Hash值我们得出某元素不在集合中，那么该元素肯定不在集合中。只有在所有的Hash函数告诉我们该元素在集合中时，才能确定该元素存在于集合中。这便是Bloom-Filter的基本思想。
Bloom-Filter一般用于在大数据量的集合中判定某元素是否存在。

#### 缓存击穿

**缓存击穿**是指缓存中没有但数据库中有的数据（一般是缓存时间到期），这时由于并发用户特别多，同时读缓存没读到数据，又同时去数据库去取数据，引起数据库压力瞬间增大，造成过大压力。和缓存雪崩不同的是，缓存击穿指并发查同一条数据，缓存雪崩是不同数据都过期了，很多数据都查不到从而查数据库。

**解决方案**

1. 设置热点数据永远不过期。
2. 加互斥锁，互斥锁

#### 缓存预热

**缓存预热**就是系统上线后，将相关的缓存数据直接加载到缓存系统。这样就可以避免在用户请求的时候，先查询数据库，然后再将数据缓存的问题！用户直接查询事先被预热的缓存数据！

**解决方案**

1. 直接写个缓存刷新页面，上线时手工操作一下；
2. 数据量不大，可以在项目启动的时候自动进行加载；
3. 定时刷新缓存；

#### 缓存降级

当访问量剧增、服务出现问题（如响应时间慢或不响应）或非核心服务影响到核心流程的性能时，仍然需要保证服务还是可用的，即使是有损服务。系统可以根据一些关键数据进行自动降级，也可以配置开关实现人工降级。

**缓存降级**的最终目的是保证核心服务可用，即使是有损的。而且有些服务是无法降级的（如加入购物车、结算）。

在进行降级之前要对系统进行梳理，看看系统是不是可以丢卒保帅；从而梳理出哪些必须誓死保护，哪些可降级；比如可以参考日志级别设置预案：

1. 一般：比如有些服务偶尔因为网络抖动或者服务正在上线而超时，可以自动降级；
2. 警告：有些服务在一段时间内成功率有波动（如在95~100%之间），可以自动降级或人工降级，并发送告警；
3. 错误：比如可用率低于90%，或者数据库连接池被打爆了，或者访问量突然猛增到系统能承受的最大阀值，此时可以根据情况自动降级或者人工降级；
4. 严重错误：比如因为特殊原因数据错误了，此时需要紧急人工降级。

服务降级的目的，是为了防止Redis服务故障，导致数据库跟着一起发生雪崩问题。因此，对于不重要的缓存数据，可以采取服务降级策略，例如一个比较常见的做法就是，Redis出现问题，不去数据库查询，而是直接返回默认值给用户。

#### 热点数据和冷数据

热点数据，缓存才有价值

对于冷数据而言，大部分数据可能还没有再次访问到就已经被挤出内存，不仅占用内存，而且价值不大。频繁修改的数据，看情况考虑使用缓存

对于热点数据，比如我们的某IM产品，生日祝福模块，当天的寿星列表，缓存以后可能读取数十万次。再举个例子，某导航产品，我们将导航信息，缓存以后可能读取数百万次。

数据更新前至少读取两次，缓存才有意义。这个是最基本的策略，如果缓存还没有起作用就失效了，那就没有太大价值了。

那存不存在，修改频率很高，但是又不得不考虑缓存的场景呢？有！比如，这个读取接口对数据库的压力很大，但是又是热点数据，这个时候就需要考虑通过缓存手段，减少数据库的压力，比如我们的某助手产品的，点赞数，收藏数，分享数等是非常典型的热点数据，但是又不断变化，此时就需要将数据同步保存到Redis缓存，减少数据库压力。

#### 缓存热点key

缓存中的一个Key(比如一个促销商品)，在某个时间点过期的时候，恰好在这个时间点对这个Key有大量的并发请求过来，这些请求发现缓存过期一般都会从后端DB加载数据并回设到缓存，这个时候大并发的请求可能会瞬间把后端DB压垮。

**解决方案**

对缓存查询加锁，如果KEY不存在，就加锁，然后查DB入缓存，然后解锁；其他进程如果发现有锁就等待，然后等解锁后返回数据或者进入DB查询

### spring cloud组件

- Eureka：各个服务启动时，Eureka Client都会将服务注册到Eureka Server，并且Eureka Client还可以反过来从Eureka Server拉取注册表，从而知道其他服务在哪里
- Ribbon：服务间发起请求的时候，基于Ribbon做负载均衡，从一个服务的多台机器中选择一台
- Feign：基于Feign的动态代理机制，根据注解和选择的机器，拼接请求URL地址，发起请求
- Hystrix：发起请求是通过Hystrix的线程池来走的，不同的服务走不同的线程池，实现了不同服务调用的隔离，避免了服务雪崩的问题
- Zuul：如果前端、移动端要调用后端系统，统一从Zuul网关进入，由Zuul网关转发请求给对应的服务

### 分布式事务解决方式

#### 1、两阶段提交协议（2PC）

　　解决分布式系统的数据一致性问题出现了两阶段提交协议（2 Phase Commitment Protocol），

两阶段提交由协调者和参与者组成，**共经过两个阶段和三个操作**，部分关系数据库如Oracle、MySQL支持两阶段提交协议。

说到2pc就不得不聊聊数据库分布式事务中的XA transactions

在XA协议中分为两阶段:

- 第一阶段：事务管理器要求每个涉及到事务的数据库预提交(precommit)此操作，并反映是否可以提交.
- 第二阶段：事务协调器要求每个数据库提交数据，或者回滚数据。

![img](https://img2020.cnblogs.com/blog/1917908/202007/1917908-20200721222624187-1361107221.png)

**举一个例子：**

**![img](https://img2020.cnblogs.com/blog/1917908/202007/1917908-20200721222646868-846007925.png)**

1、应用程序通过事务协调器向两个库发起prepare，两个数据库收到消息分别执行本地事务（记录日志），

　　但不提交，如果执行成功则回复yes，否则回复no。

2、事务协调器收到回复，只要有一方回复no则分别向参与者发起回滚事务，参与者开始回滚事务。

3、事务协调器收到回复，全部回复yes，此时向参与者发起提交事务。

　　如果参与者有一方提交事务失败则由事务协调器发起回滚事务。

**优点：**

　　尽量保证了数据的强一致，实现成本较低，在各大主流数据库都有自己实现，对于**MySQL是从5.5开始支持**。

**缺点:**

**单点问题:**事务管理器在整个流程中扮演的角色很关键，如果其宕机，比如在第一阶段已经完成，

　　在第二阶段正准备提交的时候事务管理器宕机，资源管理器就会一直阻塞，导致数据库无法使用。

**同步阻塞**:在准备就绪之后，资源管理器中的资源一直处于阻塞，直到提交完成，释放资源。

**数据不一致**:两阶段提交协议虽然为分布式数据强一致性所设计，但仍然存在数据不一致性的可能，比如在第二阶段中，

假设协调者发出了事务commit的通知，但是因为网络问题该通知仅被一部分参与者所收到并执行了commit操作，

其余的参与者则因为没有收到通知一直处于阻塞状态，这时候就产生了数据的不一致性。

#### 2、事务补偿（TCC）

　　TCC事务补偿是基于2PC实现的业务层事务控制方案，它是Try、Confirm和Cancel三个单词的首字母，含义如下：

- 1、Try 检查及预留业务资源完成提交事务前的检查，并预留好资源。
- 2、Confirm 确定执行业务操作，对try阶段预留的资源正式执行。
- 3、Cancel 取消执行业务操作，对try阶段预留的资源释放。

TCC方案在电商、金融领域落地较多。TCC方案其实是两阶段提交的一种改进。

其将整个业务逻辑的每个分支显式的分成了Try、Confirm、Cancel三个操作。

Try部分完成业务的准备工作，confirm部分完成业务的提交，cancel部分完成事务的回滚。

基本原理如下图所示。

![img](https://img2020.cnblogs.com/blog/1917908/202007/1917908-20200721223057927-275575535.png)

事务开始时，业务应用会向事务协调器注册启动事务。之后业务应用会调用所有服务的try接口，

完成一阶段准备。之后事务协调器会根据try接口返回情况，决定调用confirm接口或者cancel接口。

如果接口调用失败，会进行重试。

**举一个例子：下单减库存的业务**

**![img](https://img2020.cnblogs.com/blog/1917908/202007/1917908-20200721223131905-821929157.png)**

1、Try

​		下单业务由订单服务和库存服务协同完成，在try阶段订单服务和库存服务完成检查和预留资源。

​		订单服务检查当前是否满足提交订单的条件（比如：当前存在未完成订单的不允许提交新订单）。

​		库存服务检查当前是否有充足的库存，并锁定资源。

2、Confirm

​		订单服务和库存服务成功完成Try后开始正式执行资源操作。

​		订单服务向订单写一条订单信息。

​		库存服务减去库存。

3、Cancel

​		如果订单服务和库存服务有一方出现失败则全部取消操作。

​		订单服务需要删除新增的订单信息。

​		库存服务将减去的库存再还原。

**优点：**

最终保证数据的一致性，在业务层实现事务控制，灵活性好。

**缺点：**

开发成本高，每个事务操作每个参与者都需要实现try/confirm/cancel三个接口。

**注意：**

TCC的try/confirm/cancel接口都要实现幂等性（幂等性是指同一个操作无论请求多少次，其结果都相同。），

在为在try、confirm、cancel失败后要不断重试。

#### 3、消息队列实现最终一致

　　本方案是将分布式事务拆分成多个本地事务来完成，并且由消息队列异步协调完成，如下图：下边以下单减少库存为例来说明：

![img](https://img2020.cnblogs.com/blog/1917908/202007/1917908-20200721223950016-1909153879.png)

1、订单服务和库存服务完成检查和预留资源。

2、订单服务在本地事务中完成添加订单表记录和添加“减少库存任务消息”。

3、由定时任务根据消息表的记录发送给MQ通知库存服务执行减库存操作。

4、库存服务执行减少库存，并且记录执行消息状态（为避免重复执行消息，在执行减库存之前查询是否执行过此消息）。

5、库存服务向MQ发送完成减少库存的消息。

6、订单服务接收到完成库存减少的消息后删除原来添加的“减少库存任务消息”。

实现最终事务一致要求：预留资源成功理论上要求正式执行成功，如果执行失败会进行重试，要求业务执行方法实现幂等。

**优点 ：**

由MQ按异步的方式协调完成事务，性能较高。

不用实现try/confirm/cancel接口，开发成本比TCC低。

**缺点：**

此方式基于关系数据库本地事务来实现，会出现频繁读写数据库记录，浪费数据库资源，另外对于高并发操作不是最佳方案。

### 设计模式



## 二、联信

笔试：
java列表排序
数据库隔离级别

单例模式

面试可能问的：
比较好的功能开发 经历
excel大数据库导入导出
sql优化经验
hashMap的理解
接口幂等性
线程池
redis高可用分布式锁
避免长事务处理的解决方案
线程池
还有啥 数据库 mongo mysql 乐观锁 悲观锁。之类的

![微信图片_20201021133352](E:\知识整理\微信图片_20201021133352.jpg)

![微信图片_20201021133400](E:\知识整理\微信图片_20201021133400.jpg)

![微信图片_20201021133406](E:\知识整理\微信图片_20201021133406.jpg)

![微信图片_20201021133412](E:\知识整理\微信图片_20201021133412.jpg)

#知识点整理

## 一、JAVA基础

#### 8种基本数据类型

- 基本数据类型
  - 数值型
  - 整数类型(byte,short,int,long)
  - 浮点类型(float,double)
  - 字符型(char)
  - 布尔型(boolean)
- 引用数据类型
  - 类(class)
  - 接口(interface)
  - 数组([])

![img](https://imgconvert.csdnimg.cn/aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL0pvdXJXb24vaW1hZ2UvbWFzdGVyL0phdmElRTUlOUYlQkElRTclQTElODAlRTglQUYlQUQlRTYlQjMlOTUvSmF2YSVFNSU5RiVCQSVFNiU5QyVBQyVFNiU5NSVCMCVFNiU4RCVBRSVFNyVCMSVCQiVFNSU5RSU4Qi5wbmc?x-oss-process=image/format,png)

#### **访问修饰符**

private : 在同一类内可见。使用对象：变量、方法。 注意：不能修饰类（外部类）
default : 在同一包内可见，不使用任何修饰符。使用对象：类、接口、变量、方法。
protected : 对同一包内的类和所有子类可见。使用对象：变量、方法。 注意：不能修饰类（外部类）。
public : 对所有类可见。使用对象：类、接口、变量、方法

![img](https://imgconvert.csdnimg.cn/aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL0pvdXJXb24vaW1hZ2UvbWFzdGVyL0phdmElRTUlOUYlQkElRTclQTElODAlRTglQUYlQUQlRTYlQjMlOTUvSmF2YSVFOCVBRSVCRiVFOSU5NyVBRSVFNCVCRiVBRSVFOSVBNSVCMCVFNyVBQyVBNi5wbmc?x-oss-process=image/format,png)

#### &和&&的区别

&运算符有两种用法：(1)按位与；(2)逻辑与。

&&运算符是短路与运算。逻辑与跟短路与的差别是非常巨大的，虽然二者都要求运算符左右两端的布尔值都是true 整个表达式的值才是 true。&&之所以称为短路运算，是因为如果&&左边的表达式的值是 false，右边的表达式会被直接短路掉，不会进行运算。

注意：逻辑或运算符（|）和短路或运算符（||）的差别也是如此。

#### final 有什么用？

用于修饰类、属性和方法；

- 被final修饰的类不可以被继承
- 被final修饰的方法不可以被重写
- 被final修饰的变量不可以被改变，被final修饰不可变的是变量的引用，而不是引用指向的内容，引用指向的内容是可以改变的

#### this关键字的用法

this是自身的一个对象，代表对象本身，可以理解为：指向对象本身的一个指针。

this的用法在java中大体可以分为3种：

1.普通的直接引用，this相当于是指向当前对象本身。

2.形参与成员名字重名，用this来区分

3.引用本类的构造函数

#### super关键字的用法

super可以理解为是指向自己超（父）类对象的一个指针，而这个超类指的是离自己最近的一个父类。

super也有三种用法：

1.普通的直接引用

与this类似，super相当于是指向当前对象的父类的引用，这样就可以用super.xxx来引用父类的成员。

2.子类中的成员变量或方法与父类中的成员变量或方法同名时，用super进行区分

3.引用父类构造函数

- super（参数）：调用父类中的某一个构造函数（应该为构造函数中的第一条语句）。
- this（参数）：调用本类中另一种形式的构造函数（应该为构造函数中的第一条语句）。

#### this与super的区别

- super:　它引用当前对象的直接父类中的成员（用来访问直接父类中被隐藏的父类中成员数据或函数，基类与派生类中有相同成员定义时如：super.变量名 super.成员函数据名（实参）
- this：它代表当前对象名（在程序中易产生二义性之处，应使用this来指明当前对象；如果函数的形参与类中的成员数据同名，这时需用this来指明成员变量名）
- super()和this()类似,区别是，super()在子类中调用父类的构造方法，this()在本类内调用本类的其它构造方法。
- super()和this()均需放在构造方法内第一行。
- 尽管可以用this调用一个构造器，但却不能调用两个。
- this和super不能同时出现在一个构造函数里面，因为this必然会调用其它的构造函数，其它的构造函数必然也会有super语句的存在，所以在同一个构造函数里面有相同的语句，就失去了语句的意义，编译器也不会通过。
- this()和super()都指的是对象，所以，均不可以在static环境中使用。包括：static变量,static方法，static语句块。
- 从本质上讲，this是一个指向本对象的指针, 然而super是一个Java关键字。

#### static存在的主要意义

static的主要意义是在于创建独立于具体对象的域变量或者方法。**以致于即使没有创建对象，也能使用属性和调用方法**！

static关键字还有一个比较关键的作用就是 **用来形成静态代码块以优化程序性能**。static块可以置于类中的任何地方，类中可以有多个static块。在类初次被加载的时候，会按照static块的顺序来执行每个static块，并且只会执行一次。

为什么说static块可以用来优化程序性能，是因为它的特性:只会在类加载的时候执行一次。因此，很多时候会将一些只需要进行一次的初始化操作都放在static代码块中进行。

#### static的独特之处

1、被static修饰的变量或者方法是独立于该类的任何对象，也就是说，这些变量和方法**不属于任何一个实例对象，而是被类的实例对象所共享**。

> 怎么理解 “被类的实例对象所共享” 这句话呢？就是说，一个类的静态成员，它是属于大伙的【大伙指的是这个类的多个对象实例，我们都知道一个类可以创建多个实例！】，所有的类对象共享的，不像成员变量是自个的【自个指的是这个类的单个实例对象】…我觉得我已经讲的很通俗了，你明白了咩？

2、在该类被第一次加载的时候，就会去加载被static修饰的部分，而且只在类第一次使用时加载并进行初始化，注意这是第一次用就要初始化，后面根据需要是可以再次赋值的。

3、static变量值在类加载的时候分配空间，以后创建类对象的时候不会重新分配。赋值的话，是可以任意赋值的！

4、被static修饰的变量或者方法是优先于对象存在的，也就是说当一个类加载完毕之后，即便没有创建对象，也可以去访问。

#### static应用场景

因为static是被类的实例对象所共享，因此如果**某个成员变量是被所有对象所共享的，那么这个成员变量就应该定义为静态变量**。

因此比较常见的static应用场景有：

> 1、修饰成员变量 2、修饰成员方法 3、静态代码块 4、修饰类【只能修饰内部类也就是静态内部类】 5、静态导包

#### static注意事项

1、静态只能访问静态。 2、非静态既可以访问非静态的，也可以访问静态的。

#### break ,continue ,return 的区别及作用

break 跳出总上一层循环，不再执行循环(结束当前的循环体)

continue 跳出本次循环，继续执行下次循环(结束正在执行的循环 进入下一个循环条件)

return 程序返回，不再执行下面的代码(结束当前的方法 直接返回)

#### BIO,NIO,AIO 有什么区别?

简答

- BIO：Block IO 同步阻塞式 IO，就是我们平常使用的传统 IO，它的特点是模式简单使用方便，并发处理能力低。
- NIO：Non IO 同步非阻塞 IO，是传统 IO 的升级，客户端和服务器端通过 Channel（通道）通讯，实现了多路复用。
- AIO：Asynchronous IO 是 NIO 的升级，也叫 NIO2，实现了异步非堵塞 IO ，异步 IO 的操作基于事件和回调机制。

详细回答

- **BIO (Blocking I/O):** 同步阻塞I/O模式，数据的读取写入必须阻塞在一个线程内等待其完成。在活动连接数不是特别高（小于单机1000）的情况下，这种模型是比较不错的，可以让每一个连接专注于自己的 I/O 并且编程模型简单，也不用过多考虑系统的过载、限流等问题。线程池本身就是一个天然的漏斗，可以缓冲一些系统处理不了的连接或请求。但是，当面对十万甚至百万级连接的时候，传统的 BIO 模型是无能为力的。因此，我们需要一种更高效的 I/O 处理模型来应对更高的并发量。
- **NIO (New I/O):** NIO是一种同步非阻塞的I/O模型，在Java 1.4 中引入了NIO框架，对应 java.nio 包，提供了 Channel , Selector，Buffer等抽象。NIO中的N可以理解为Non-blocking，不单纯是New。它支持面向缓冲的，基于通道的I/O操作方法。 NIO提供了与传统BIO模型中的 `Socket` 和 `ServerSocket` 相对应的 `SocketChannel` 和 `ServerSocketChannel` 两种不同的套接字通道实现,两种通道都支持阻塞和非阻塞两种模式。阻塞模式使用就像传统中的支持一样，比较简单，但是性能和可靠性都不好；非阻塞模式正好与之相反。对于低负载、低并发的应用程序，可以使用同步阻塞I/O来提升开发速率和更好的维护性；对于高负载、高并发的（网络）应用，应使用 NIO 的非阻塞模式来开发
- **AIO (Asynchronous I/O):** AIO 也就是 NIO 2。在 Java 7 中引入了 NIO 的改进版 NIO 2,它是异步非阻塞的IO模型。异步 IO 是基于事件和回调机制实现的，也就是应用操作之后会直接返回，不会堵塞在那里，当后台处理完成，操作系统会通知相应的线程进行后续的操作。AIO 是异步IO的缩写，虽然 NIO 在网络操作中，提供了非阻塞的方法，但是 NIO 的 IO 行为还是同步的。对于 NIO 来说，我们的业务线程是在 IO 操作准备好时，得到通知，接着就由这个线程自行进行 IO 操作，IO操作本身是同步的。查阅网上相关资料，我发现就目前来说 AIO 的应用还不是很广泛，Netty 之前也尝试使用过 AIO，不过又放弃了。

#### 抽象类和接口的对比

抽象类是用来捕捉子类的通用特性的。接口是抽象方法的集合。

从设计层面来说，抽象类是对类的抽象，是一种模板设计，接口是行为的抽象，是一种行为的规范。

**相同点**

- 接口和抽象类都不能实例化
- 都位于继承的顶端，用于被其他实现或继承
- 都包含抽象方法，其子类都必须覆写这些抽象方法

**不同点**

| 参数       | 抽象类                                                       | 接口                                                         |
| ---------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 声明       | 抽象类使用abstract关键字声明                                 | 接口使用interface关键字声明                                  |
| 实现       | 子类使用extends关键字来继承抽象类。如果子类不是抽象类的话，它需要提供抽象类中所有声明的方法的实现 | 子类使用implements关键字来实现接口。它需要提供接口中所有声明的方法的实现 |
| 构造器     | 抽象类可以有构造器                                           | 接口不能有构造器                                             |
| 访问修饰符 | 抽象类中的方法可以是任意访问修饰符                           | 接口方法默认修饰符是public。并且不允许定义为 private 或者 protected |
| 多继承     | 一个类最多只能继承一个抽象类                                 | 一个类可以实现多个接口                                       |
| 字段声明   | 抽象类的字段声明可以是任意的                                 | 接口的字段默认都是 static 和 final 的                        |



#### 静态方法和实例方法有何不同？

静态方法和实例方法的区别主要体现在两个方面：

1. 在外部调用静态方法时，可以使用"类名.方法名"的方式，也可以使用"对象名.方法名"的方式。而实例方法只有后面这种方式。也就是说，调用静态方法可以无需创建对象。
2. 静态方法在访问本类的成员时，只允许访问静态成员（即静态成员变量和静态方法），而不允许访问实例成员变量和实例方法；实例方法则无此限制

#### 重载（Overload）和重写（Override）的区别。重载的方法能否根据返回类型进行区分？

方法的重载和重写都是实现多态的方式，区别在于前者实现的是编译时的多态性，而后者实现的是运行时的多态性。

重载：发生在同一个类中，方法名相同参数列表不同（参数类型不同、个数不同、顺序不同），与方法返回值和访问修饰符无关，即重载的方法不能根据返回类型进行区分

重写：发生在父子类中，方法名、参数列表必须相同，返回值小于等于父类，抛出的异常小于等于父类，访问修饰符大于等于父类（里氏代换原则）；如果父类方法访问修饰符为private则子类中就不是重写。

#### 对象相等判断

##### == 和 equals 的区别是什么

**==** : 它的作用是判断两个对象的地址是不是相等。即，判断两个对象是不是同一个对象。(基本数据类型 == 比较的是值，引用数据类型 == 比较的是内存地址)

**equals()** : 它的作用也是判断两个对象是否相等。但它一般有两种使用情况：

情况1：类没有覆盖 equals() 方法。则通过 equals() 比较该类的两个对象时，等价于通过“==”比较这两个对象。

情况2：类覆盖了 equals() 方法。一般，我们都覆盖 equals() 方法来两个对象的内容相等；若它们的内容相等，则返回 true (即，认为这两个对象相等)。

**说明：**

- String中的equals方法是被重写过的，因为object的equals方法是比较的对象的内存地址，而String的equals方法比较的是对象的值。
- 当创建String类型的对象时，虚拟机会在常量池中查找有没有已经存在的值和要创建的值相同的对象，如果有就把它赋给当前引用。如果没有就在常量池中重新创建一个String对象。

#### hashCode 与 equals (重要)

**hashCode()介绍**

hashCode() 的作用是获取哈希码，也称为散列码；它实际上是返回一个int整数。这个哈希码的作用是确定该对象在哈希表中的索引位置。hashCode() 定义在JDK的Object.java中，这就意味着Java中的任何类都包含有hashCode()函数。

散列表存储的是键值对(key-value)，它的特点是：能根据“键”快速的检索出对应的“值”。这其中就利用到了散列码！（可以快速找到所需要的对象）

**为什么要有 hashCode**

**我们以“HashSet 如何检查重复”为例子来说明为什么要有 hashCode**：

当你把对象加入 HashSet 时，HashSet 会先计算对象的 hashcode 值来判断对象加入的位置，同时也会与其他已经加入的对象的 hashcode 值作比较，如果没有相符的hashcode，HashSet会假设对象没有重复出现。但是如果发现有相同 hashcode 值的对象，这时会调用 equals()方法来检查 hashcode 相等的对象是否真的相同。如果两者相同，HashSet 就不会让其加入操作成功。如果不同的话，就会重新散列到其他位置。（摘自我的Java启蒙书《Head first java》第二版）。这样我们就大大减少了 equals 的次数，相应就大大提高了执行速度。

**hashCode()与equals()的相关规定**

如果两个对象相等，则hashcode一定也是相同的

两个对象相等，对两个对象分别调用equals方法都返回true

两个对象有相同的hashcode值，它们也不一定是相等的

**因此，equals 方法被覆盖过，则 hashCode 方法也必须被覆盖**

hashCode() 的默认行为是对堆上的对象产生独特值。如果没有重写 hashCode()，则该 class 的两个对象无论如何都不会相等（即使这两个对象指向相同的数据）

#### 对象的相等与指向他们的引用相等，两者有什么不同？

对象的相等 比的是内存中存放的内容是否相等而 引用相等 比较的是他们指向的内存地址是否相等。



### 反射

### 什么是反射机制？

JAVA反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法的功能称为java语言的反射机制。

静态编译和动态编译

- **静态编译：**在编译时确定类型，绑定对象
- **动态编译：**运行时确定类型，绑定对象

### 反射机制优缺点

- **优点：** 运行期类型的判断，动态加载类，提高代码灵活度。
- **缺点：** 性能瓶颈：反射相当于一系列解释操作，通知 JVM 要做的事情，性能比直接的java代码要慢很多。

#### 反射机制的应用场景有哪些？

反射是框架设计的灵魂。

在我们平时的项目开发过程中，基本上很少会直接使用到反射机制，但这不能说明反射机制没有用，实际上有很多设计、开发都与反射机制有关，例如模块化的开发，通过反射去调用对应的字节码；动态代理设计模式也采用了反射机制，还有我们日常使用的 Spring／Hibernate 等框架也大量使用到了反射机制。

举例：①我们在使用JDBC连接数据库时使用Class.forName()通过反射加载数据库的驱动程序；

②Spring框架也用到很多反射机制，最经典的就是xml的配置模式。

Spring 通过 XML 配置模式装载 Bean 的过程：

1) 将程序内所有 XML 或 Properties 配置文件加载入内存中; 

2) Java类里面解析xml或properties里面的内容，得到对应实体类的字节码字符串以及相关的属性信息;

3)使用反射机制，根据这个字符串获得某个类的Class实例; 

4)动态配置实例的属性

#### Java获取反射的三种方法

1.通过new对象实现反射机制 2.通过路径实现反射机制 3.通过类名实现反射机制



#### 在使用 HashMap 的时候，用 String 做 key 有什么好处？

HashMap 内部实现是通过 key 的 hashcode 来确定 value 的存储位置，因为字符串是不可变的，所以当创建字符串时，它的 hashcode 被缓存下来，不需要再次计算，所以相比于其他对象更快。



#### String和StringBuffer、StringBuilder的区别是什么？String为什么是不可变的

**可变性**

String类中使用字符数组保存字符串，private　final　char　value[]，所以string对象是不可变的。StringBuilder与StringBuffer都继承自AbstractStringBuilder类，在AbstractStringBuilder中也是使用字符数组保存字符串，char[] value，这两种对象都是可变的。

**线程安全性**

String中的对象是不可变的，也就可以理解为常量，线程安全。AbstractStringBuilder是StringBuilder与StringBuffer的公共父类，定义了一些字符串的基本操作，如expandCapacity、append、insert、indexOf等公共方法。StringBuffer对方法加了同步锁或者对调用的方法加了同步锁，所以是线程安全的。StringBuilder并没有对方法进行加同步锁，所以是非线程安全的。

**性能**

每次对String 类型进行改变的时候，都会生成一个新的String对象，然后将指针指向新的String 对象。StringBuffer每次都会对StringBuffer对象本身进行操作，而不是生成新的对象并改变对象引用。相同情况下使用StirngBuilder 相比使用StringBuffer 仅能获得10%~15% 左右的性能提升，但却要冒多线程不安全的风险。

**对于三者使用的总结**

如果要操作少量的数据用 = String

单线程操作字符串缓冲区 下操作大量数据 = StringBuilder

多线程操作字符串缓冲区 下操作大量数据 = StringBuffer

#### 自动装箱与拆箱

**装箱**：将基本类型用它们对应的引用类型包装起来；

**拆箱**：将包装类型转换为基本数据类型；

#### int 和 Integer 有什么区别

Java 是一个近乎纯洁的面向对象编程语言，但是为了编程的方便还是引入了基本数据类型，但是为了能够将这些基本数据类型当成对象操作，Java 为每一个基本数据类型都引入了对应的包装类型（wrapper class），int 的包装类就是 Integer，从 Java 5 开始引入了自动装箱/拆箱机制，使得二者可以相互转换。

Java 为每个原始类型提供了包装类型：

原始类型: boolean，char，byte，short，int，long，float，double

包装类型：Boolean，Character，Byte，Short，Integer，Long，Float，Double

#### Integer a= 127 与 Integer b = 127相等吗

对于对象引用类型：==比较的是对象的内存地址。
对于基本数据类型：==比较的是值。

如果整型字面量的值在-128到127之间，那么自动装箱时不会new新的Integer对象，而是直接引用常量池中的Integer对象，超过范围 a1==b1的结果是false

### 集合和数组的区别

- 数组是固定长度的；集合可变长度的。
- 数组可以存储基本数据类型，也可以存储引用数据类型；集合只能存储引用数据类型。
- 数组存储的元素必须是同一个数据类型；集合存储的对象可以是不同数据类型。

### 常用的集合类有哪些？

Map接口和Collection接口是所有集合框架的父接口：

1. Collection接口的子接口包括：Set接口和List接口
2. Map接口的实现类主要有：HashMap、TreeMap、Hashtable、ConcurrentHashMap以及Properties等
3. Set接口的实现类主要有：HashSet、TreeSet、LinkedHashSet等
4. List接口的实现类主要有：ArrayList、LinkedList、Stack以及Vector等

Java 容器分为 Collection 和 Map 两大类，Collection集合的子接口有Set、List、Queue三种子接口。我们比较常用的是Set、List，Map接口不是collection的子接口。





Collection集合主要有List和Set两大接口

- List：一个有序（元素存入集合的顺序和取出的顺序一致）容器，元素可以重复，可以插入多个null元素，元素都有索引。常用的实现类有 ArrayList、LinkedList 和 Vector。
- Set：一个无序（存入和取出顺序有可能不一致）容器，不可以存储重复元素，只允许存入一个null元素，必须保证元素唯一性。Set 接口常用实现类是 HashSet、LinkedHashSet 以及 TreeSet。

Map是一个键值对集合，存储键、值和之间的映射。 Key无序，唯一；value 不要求有序，允许重复。Map没有继承于Collection接口，从Map集合中检索元素时，只要给出键对象，就会返回对应的值对象。

Map 的常用实现类：HashMap、TreeMap、HashTable、LinkedHashMap、ConcurrentHashMap



### 集合框架底层数据结构

Collection

1. List

- Arraylist： Object数组
- Vector： Object数组
- LinkedList： 双向循环链表

1. Set

- HashSet（无序，唯一）：基于 HashMap 实现的，底层采用 HashMap 来保存元素
- LinkedHashSet： LinkedHashSet 继承与 HashSet，并且其内部是通过 LinkedHashMap 来实现的。有点类似于我们之前说的LinkedHashMap 其内部是基于 Hashmap 实现一样，不过还是有一点点区别的。
- TreeSet（有序，唯一）： 红黑树(自平衡的排序二叉树。)

Map

- HashMap： JDK1.8之前HashMap由数组+链表组成的，数组是HashMap的主体，链表则是主要为了解决哈希冲突而存在的（“拉链法”解决冲突）.JDK1.8以后在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为8）时，将链表转化为红黑树，以减少搜索时间
- LinkedHashMap：LinkedHashMap 继承自 HashMap，所以它的底层仍然是基于拉链式散列结构即由数组和链表或红黑树组成。另外，LinkedHashMap 在上面结构的基础上，增加了一条双向链表，使得上面的结构可以保持键值对的插入顺序。同时通过对链表进行相应的操作，实现了访问顺序相关逻辑。
- HashTable： 数组+链表组成的，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突而存在的
- TreeMap： 红黑树（自平衡的排序二叉树）

### 哪些集合类是线程安全的？

- vector：就比arraylist多了个同步化机制（线程安全），因为效率较低，现在已经不太建议使用。在web应用中，特别是前台页面，往往效率（页面响应速度）是优先考虑的。
- statck：堆栈类，先进后出。
- hashtable：就比hashmap多了个线程安全。
- enumeration：枚举，相当于迭代器。

#### 迭代器 Iterator 是什么？

Iterator 接口提供遍历任何 Collection 的接口。我们可以从一个 Collection 中使用迭代器方法来获取迭代器实例。迭代器取代了 Java 集合框架中的 Enumeration，迭代器允许调用者在迭代过程中移除元素。





## 二、集合容器

## 三、异常

## 四、并发

## 五、JVM

## 六、Spring

## 七、Spring Boot

## 二、集合容器

## 二、集合容器

## 二、集合容器

## 二、集合容器





# 速记版

## 一、Java 基础

### 1. JDK 和 JRE 有什么区别？

- JDK：Java Development Kit 的**简**称**，**Java 开发工具包**，**提供了 Java 的开发环境和运行环境。
- JRE：Java Runtime Environment 的**简**称**，**Java 运行环境**，**为 Java 的运行提供了所需环境。

具体来说 JDK 其实包含了 JRE**，**同时还包含了编译 Java 源码的编译器 Javac**，**还包含了很多 Java 程序调试和分析的工具。**简**单来说：如果你需要运行 Java 程序**，**只需安装 JRE 就可以了**，**如果你需要编写 Java 程序**，**需要安装 JDK。

### 2. == 和 equals 的区别是什么？

**== 的作用**

- 基本类型：比较的是值是否相同。
- 引用类型：比较的是引用是否相同。

**equals 的作用**：比较的都是值是否相同。

代码示例：

```
String x = "string";



String y = "string";



String z = new String("string");



System. out. println(x==y); // true



System. out. println(x==z); // false



System. out. println(x. equals(y)); // true



System. out. println(x. equals(z)); // true



 
```

代码解读：因为 x 和 y 指向的是同一个引用**，**所以 == 也是 true**，**而 new String() 方法则重写开辟了内存空间**，**所以 == 结果为 false**，**而 equals 比较的一直是值**，**所以结果都为 true。

### 3. 两个对象的 hashCode() 相同**，**则 equals() 也一定为 true**，**对吗？

不对**，**两个对象的 hashCode() 相同**，**equals() 不一定 true。

代码示例：

```
String str1 = "通话";



String str2 = "重地";



System. out. println(String. format("str1：%d | str2：%d",  str1\. hashCode(),str2\. hashCode()));



System. out. println(str1\. equals(str2));



 
```

执行的结果：

```
str1：1179395 | str2：1179395



 



false



 
```

代码解读：很显然“通话”和“重地”的 hashCode() 相同**，**然而 equals() 则为 false**，**因为在散列表中**，**hashCode() 相等即两个键值对的哈希值相等**，**然而哈希值相等**，**并不一定能得出键值对相等。

### 4. final 在 Java 中有什么作用？

- final 修饰的类叫最终类**，**该类不能被继承。
- final 修饰的方法不能被重写。
- final 修饰的变量叫常量**，**常量必须初始化**，**初始化之后值就不能被修改。

### 5. Java 中的 Math. round(-1. 5) 等于多少？

等于 -1**，**Math. round 四舍五入大于 0. 5 向上取整的。

### 6. String 属于基础的数据类型吗？

String 不属于基础类型**，**基础类型有 8 种：byte、boolear、char、short、int、float、long、double**，**String 属于对象。

### 7. Java 中操作字符串都有哪些类？它们之间有什么区别？

操作字符串的类有：String、StringBuffer、StringBuilder。

String 和 StringBuffer、StringBuilder 的区别在于 String 声明的是不可变的对象**，**每次操作都会生成新的 String 对象**，**然后将指针指向新的 String 对象**，**而 StringBuffer、StringBuilder 可以在原有对象的基础上进行操作**，**所以在经常改变字符串内容的情况**下**最好不要使用 String。

StringBuffer 和 StringBuilder 最大的区别在于**，**StringBuffer 是线程安全的**，**而 StringBuilder 是非线程安全的**，**但 StringBuilder 的性能却高于 StringBuffer**，**所以在单线程环境**下**推荐使用 StringBuilder**，**多线程环境**下**推荐使用 StringBuffer。

### 8. String str="i"与 String str=new String("i")一样吗？

不一样**，**因为内存的分配方式不一样。String str="i"的方式**，**Java 虚拟机会将其分配到常量池中；而 String str=new String("i") 则会被分到堆内存中。

### 9. 如何将字符串反转？

使用 StringBuilder 或者 stringBuffer 的 reverse() 方法。

示例代码：

```
// StringBuffer reverse



StringBuffer stringBuffer = new StringBuffer();



stringBuffer. append("abcdefg");



System. out. println(stringBuffer. reverse()); // gfedcba



// StringBuilder reverse



StringBuilder stringBuilder = new StringBuilder();



stringBuilder. append("abcdefg");



System. out. println(stringBuilder. reverse()); // gfedcba



 
```

### 10. String 类的常用方法都有那些？

- indexOf()：返回指定字符的索引。
- charAt()：返回指定索引处的字符。
- replace()：字符串替换。
- trim()：去除字符串两端空白。
- split()：分割字符串**，**返回一个分割后的字符串数组。
- getBytes()：返回字符串的 byte 类型数组。
- length()：返回字符串长度。
- toLowerCase()：将字符串转成小写字母。
- toUpperCase()：将字符串转成大写字符。
- substring()：截取字符串。
- equals()：字符串比较。

### 11. 抽象类必须要有抽象方法吗？

不需要**，**抽象类不一定非要有抽象方法。

示例代码：

```
abstract class Cat {



    public static void sayHi() {



        System. out. println("hi~");



    }



}



 
```

上面代码**，**抽象类并没有抽象方法但完全可以正常运行。

### 12. 普通类和抽象类有哪些区别？

- 普通类不能包含抽象方法**，**抽象类可以包含抽象方法。
- 抽象类不能直接实例化**，**普通类可以直接实例化。

### 13. 抽象类能使用 final 修饰吗？

不能**，**定义抽象类就是让其他类继承的**，**如果定义为 final 该类就不能被继承**，**这样彼此就会产生矛盾。

### 14. 接口和抽象类有什么区别？

- 默认方法实现：抽象类可以有默认的方法实现；接口不能有默认的方法实现。
- 实现：抽象类的子类使用 extends 来继承；接口必须使用 implements 来实现接口。
- 构造函数：抽象类可以有构造函数；接口不能有。
- main 方法：抽象类可以有 main 方法**，**并且我们能运行它；接口不能有 main 方法。
- 实现数量：类可以实现很多个接口；但是只能继承一个抽象类。
- 访问修饰符：接口中的方法默认使用 public 修饰；抽象类中的方法可以是任意访问修饰符。

### 15. Java 中 IO 流分为几种？

按功能来分：输入流（input）、输出流（output）。

按类型来分：字节流和字符流。

字节流和字符流的区别是：字节流按 8 位传输以字节为单位输入输出数据**，**字符流按 16 位传输以字符为单位输入输出数据。

### 16. BIO、NIO、AIO 有什么区别？

- BIO：Block IO 同步阻塞式 IO**，**就是我们平常使用的传统 IO**，**它的特点是模式**简**单使用方便**，**并发处理能力低。
- NIO：New IO 同步非阻塞 IO**，**是传统 IO 的升级**，**客户端和服务器端通过 Channel（通道）通讯**，**实现了多路复用。
- AIO：Asynchronous IO 是 NIO 的升级**，**也叫 NIO2**，**实现了异步非堵塞 IO **，**异步 IO 的操作基于事件和回调机制。

### 17. Files的常用方法都有哪些？

- Files. exists()：检测文件路径是否存在。
- Files. createFile()：创建文件。
- Files. createDirectory()：创建文件夹。
- Files. delete()：删除一个文件或目录。
- Files. copy()：复制文件。
- Files. move()：移动文件。
- Files. size()：查看文件个数。
- Files. read()：读取文件。
- Files. write()：写入文件。

## 二、容器

### 18. Java 容器都有哪些？

Java 容器分为 Collection 和 Map 两大类**，**其**下**又有很多子类**，**如**下**所示：

- Collection
- List
  - ArrayList
  - LinkedList
  - Vector
  - Stack
- Set
  - HashSet
  - LinkedHashSet
  - TreeSet
- Map
- HashMap
  - LindedHashMap
- TreeMap
- ConcurrentHashMap
- Hashtable

### 19. Collection 和 Collections 有什么区别？

- Collection 是一个集合接口**，**它提供了对集合对象进行基本操作的通用接口方法**，**所有集合都是它的子类**，**比如 List、Set 等。
- Collections 是一个包装类**，**包含了很多静态方法**，**不能被实例化**，**就像一个工具类**，**比如提供的排序方法： Collections. sort(list)。

### 20. List、Set、Map 之间的区别是什么？

List、Set、Map 的区别主要体现在两个方面：元素是否有序、是否允许元素重复。

### 21. HashMap 和 Hashtable 有什么区别？

- 存储：HashMap 运行 key 和 value 为 null**，**而 Hashtable 不允许。
- 线程安全：Hashtable 是线程安全的**，**而 HashMap 是非线程安全的。
- 推荐使用：在 Hashtable 的类注释可以看到**，**Hashtable 是保留类不建议使用**，**推荐在单线程环境**下**使用 HashMap 替代**，**如果需要多线程使用则用 ConcurrentHashMap 替代。

### 22. 如何决定使用 HashMap 还是 TreeMap？

对于在 Map 中插入、删除、定位一个元素这类操作**，**HashMap 是最好的选择**，**因为相对而言 HashMap 的插入会更快**，**但如果你要对一个 key 集合进行有序的遍历**，**那 TreeMap 是更好的选择。

### 23. 说一**下** HashMap 的实现原理？

HashMap 基于 Hash 算法实现的**，**我们通过 put(key**,**value)存储**，**get(key)来获取。当传入 key 时**，**HashMap 会根据 key. hashCode() 计算出 hash 值**，**根据 hash 值将 value 保存在 bucket 里。当计算出的 hash 值相同时**，**我们称之为 hash 冲突**，**HashMap 的做法是用链表和红黑树存储相同 hash 值的 value。当 hash 冲突的个数比较少时**，**使用链表否则使用红黑树。

### 24. 说一**下** HashSet 的实现原理？

HashSet 是基于 HashMap 实现的**，**HashSet 底层使用 HashMap 来保存所有元素**，**因此 HashSet 的实现比较**简**单**，**相关 HashSet 的操作**，**基本上都是直接调用底层 HashMap 的相关方法来完成**，**HashSet 不允许重复的值。

### 25. ArrayList 和 LinkedList 的区别是什么？

- 数据结构实现：ArrayList 是动态数组的数据结构实现**，**而 LinkedList 是双向链表的数据结构实现。
- 随机访问效率：ArrayList 比 LinkedList 在随机访问的时候效率要高**，**因为 LinkedList 是线性的数据存储方式**，**所以需要移动指针从前往后依次查找。
- 增加和删除效率：在非首尾的增加和删除操作**，**LinkedList 要比 ArrayList 效率要高**，**因为 ArrayList 增删操作要影响数组内的其他数据的**下**标。

综合来说**，**在需要频繁读取集合中的元素时**，**更推荐使用 ArrayList**，**而在插入和删除操作较多时**，**更推荐使用 LinkedList。

### 26. 如何实现数组和 List 之间的转换？

- 数组转 List：使用 Arrays. asList(array) 进行转换。
- List 转数组：使用 List 自带的 toArray() 方法。

代码示例：

```
// list to array



List<String> list = new ArrayList<String>();



list. add("王磊");



list. add("的博客");



list. toArray();



// array to list



String[] array = new String[]{"王磊","的博客"};



Arrays. asList(array);



 
```

### 27. ArrayList 和 Vector 的区别是什么？

- 线程安全：Vector 使用了 Synchronized 来实现线程同步**，**是线程安全的**，**而 ArrayList 是非线程安全的。
- 性能：ArrayList 在性能方面要优于 Vector。
- 扩容：ArrayList 和 Vector 都会根据实际的需要动态的调整容量**，**只不过在 Vector 扩容每次会增加 1 倍**，**而 ArrayList 只会增加 50%。

### 28. Array 和 ArrayList 有何区别？

- Array 可以存储基本数据类型和对象**，**ArrayList 只能存储对象。
- Array 是指定固定大小的**，**而 ArrayList 大小是自动扩展的。
- Array 内置方法没有 ArrayList 多**，**比如 addAll、removeAll、iteration 等方法只有 ArrayList 有。

### 29. 在 Queue 中 poll()和 remove()有什么区别？

- 相同点：都是返回第一个元素**，**并在队列中删除返回的对象。
- 不同点：如果没有元素 poll()会返回 null**，**而 remove()会直接抛出 NoSuchElementException 异常。

代码示例：

```
Queue<String> queue = new LinkedList<String>();



queue. offer("string"); // add



System. out. println(queue. poll());



System. out. println(queue. remove());



System. out. println(queue. size());



 
```

### 30. 哪些集合类是线程安全的？

Vector、Hashtable、Stack 都是线程安全的**，**而像 HashMap 则是非线程安全的**，**不过在 JDK 1.5 之后随着 Java. util. concurrent 并发包的出现**，**它们也有了自己对应的线程安全类**，**比如 HashMap 对应的线程安全类就是 ConcurrentHashMap。

### 31. 迭代器 Iterator 是什么？

Iterator 接口提供遍历任何 Collection 的接口。我们可以从一个 Collection 中使用迭代器方法来获取迭代器实例。迭代器取代了 Java 集合框架中的 Enumeration**，**迭代器允许调用者在迭代过程中移除元素。

### 32. Iterator 怎么使用？有什么特点？

Iterator 使用代码如**下**：

```
List<String> list = new ArrayList<>();



Iterator<String> it = list. iterator();



while(it. hasNext()){



  String obj = it. next();



  System. out. println(obj);



}



 
```

Iterator 的特点是更加安全**，**因为它可以确保**，**在当前遍历的集合元素被更改的时候**，**就会抛出 ConcurrentModificationException 异常。

### 33. Iterator 和 ListIterator 有什么区别？

- Iterator 可以遍历 Set 和 List 集合**，**而 ListIterator 只能遍历 List。
- Iterator 只能单向遍历**，**而 ListIterator 可以双向遍历（向前/后遍历）。
- ListIterator 从 Iterator 接口继承**，**然后添加了一些额外的功能**，**比如添加一个元素、替换一个元素、获取前面或后面元素的索引位置。

### 34. 怎么确保一个集合不能被修改？

可以使用 Collections. unmodifiableCollection(Collection c) 方法来创建一个只读集合**，**这样改变集合的任何操作都会抛出 Java. lang. UnsupportedOperationException 异常。

示例代码如**下**：

```
List<String> list = new ArrayList<>();



list. add("x");



Collection<String> clist = Collections. unmodifiableCollection(list);



clist. add("y"); // 运行时此行报错



System. out. println(list. size());



 
```

## 三、多线程

### 35. 并行和并发有什么区别？

- 并行：一个处理器同时处理多个任务。
- 并发：多个处理器或多核处理器同时处理多个不同的任务。

### 36. 线程和进程的区别？

一个程序**下**至少有一个进程**，**一个进程**下**至少有一个线程**，**一个进程**下**也可以有多个线程来增加程序的执行速度。

### 37. 守护线程是什么？

守护线程是运行在后台的一种特殊进程。它独立于控制终端并且周期性地执行某种任务或等待处理某些发生的事件。在 Java 中垃圾回收线程就是特殊的守护线程。

### 38. 创建线程有哪几种方式？

创建线程有三种方式：

- 继承 Thread 重新 run 方法；
- 实现 Runnable 接口；
- 实现 Callable 接口。

### 39. 说一**下** runnable 和 callable 有什么区别？

runnable 没有返回值**，**callable 可以拿到有返回值**，**callable 可以看作是 runnable 的补充。

### 40. 线程有哪些状态？

线程的状态：

- NEW 尚未启动
- RUNNABLE 正在执行中
- BLOCKED 阻塞的（被同步锁或者IO锁阻塞）
- WAITING 永久等待状态
- TIMED_WAITING 等待指定的时间重新被唤醒的状态
- TERMINATED 执行完成

### 41. sleep() 和 wait() 有什么区别？

- 类的不同：sleep() 来自 Thread**，**wait() 来自 Object。
- 释放锁：sleep() 不释放锁；wait() 释放锁。
- 用法不同：sleep() 时间到会自动恢复；wait() 可以使用 notify()/notifyAll()直接唤醒。

### 42. notify()和 notifyAll()有什么区别？

notifyAll()会唤醒所有的线程**，**notify()之后唤醒一个线程。notifyAll() 调用后**，**会将全部线程由等待池移到锁池**，**然后参与锁的竞争**，**竞争成功则继续执行**，**如果不成功则留在锁池等待锁被释放后再次参与竞争。而 notify()只会唤醒一个线程**，**具体唤醒哪一个线程由虚拟机控制。

### 43. 线程的 run() 和 start() 有什么区别？

start() 方法用于启动线程**，**run() 方法用于执行线程的运行时代码。run() 可以重复调用**，**而 start() 只能调用一次。

### 44. 创建线程池有哪几种方式？

线程池创建有七种方式**，**最核心的是最后一种：

- newSingleThreadExecutor()：它的特点在于工作线程数目被限制为 1**，**操作一个无界的工作队列**，**所以它保证了所有任务的都是被顺序执行**，**最多会有一个任务处于活动状态**，**并且不允许使用者改动线程池实例**，**因此可以避免其改变线程数目；
- newCachedThreadPool()：它是一种用来处理大量短时间工作任务的线程池**，**具有几个鲜明特点：它会试图缓存线程并重用**，**当无缓存线程可用时**，**就会创建新的工作线程；如果线程闲置的时间超过 60 秒**，**则被终止并移出缓存；长时间闲置时**，**这种线程池**，**不会消耗什么资源。其内部使用 SynchronousQueue 作为工作队列；
- newFixedThreadPool(int nThreads)：重用指定数目（nThreads）的线程**，**其背后使用的是无界的工作队列**，**任何时候最多有 nThreads 个工作线程是活动的。这意味着**，**如果任务数量超过了活动队列数目**，**将在工作队列中等待空闲线程出现；如果有工作线程退出**，**将会有新的工作线程被创建**，**以补足指定的数目 nThreads；
- newSingleThreadScheduledExecutor()：创建单线程池**，**返回 ScheduledExecutorService**，**可以进行定时或周期性的工作调度；
- newScheduledThreadPool(int corePoolSize)：和newSingleThreadScheduledExecutor()类似**，**创建的是个 ScheduledExecutorService**，**可以进行定时或周期性的工作调度**，**区别在于单一工作线程还是多个工作线程；
- newWorkStealingPool(int parallelism)：这是一个经常被人忽略的线程池**，**Java 8 才加入这个创建方法**，**其内部会构建ForkJoinPool**，**利用Work-Stealing算法**，**并行地处理任务**，**不保证处理顺序；
- ThreadPoolExecutor()：是最原始的线程池创建**，**上面1-3创建方式都是对ThreadPoolExecutor的封装。

### 45. 线程池都有哪些状态？

- RUNNING：这是最正常的状态**，**接受新的任务**，**处理等待队列中的任务。
- SHUTDOWN：不接受新的任务提交**，**但是会继续处理等待队列中的任务。
- STOP：不接受新的任务提交**，**不再处理等待队列中的任务**，**中断正在执行任务的线程。
- TIDYING：所有的任务都销毁了**，**workCount 为 0**，**线程池的状态在转换为 TIDYING 状态时**，**会执行钩子方法 terminated()。
- TERMINATED：terminated()方法结束后**，**线程池的状态就会变成这个。

### 46. 线程池中 submit() 和 execute() 方法有什么区别？

- execute()：只能执行 Runnable 类型的任务。
- submit()：可以执行 Runnable 和 Callable 类型的任务。

Callable 类型的任务可以获取执行的返回值**，**而 Runnable 执行无返回值。

### 47. 在 Java 程序中怎么保证多线程的运行安全？

- 方法一：使用安全类**，**比如 Java. util. concurrent **下**的类。
- 方法二：使用自动锁 synchronized。
- 方法三：使用手动锁 Lock。

手动锁 Java 示例代码如**下**：

```
Lock lock = new ReentrantLock();



lock. lock();



try {



    System. out. println("获得锁");



} catch (Exception e) {



    // TODO: handle exception



} finally {



    System. out. println("释放锁");



    lock. unlock();



}



 
```

### 48. 多线程锁的升级原理是什么？

在锁对象的对象头里面有一个 threadid 字段**，**在第一次访问的时候 threadid 为空**，**JVM 让其持有偏向锁**，**并将threadid 设置为其线程 id**，**再次进入的时候会先判断 threadid 是否尤其线程 id 一致**，**如果一致则可以直接使用**，**如果不一致**，**则升级偏向锁为轻量级锁**，**通过自旋循环一定次数来获取锁**，**不会堵塞**，**执行一定次数之后就会升级为重量级锁**，**进入堵塞**，**整个过程就是锁升级的原理。

锁的升级的目的：在 Java 6 之后优化 synchronized 的实现方式**，**使用了偏向锁升级为轻量级锁再升级到重量级锁的方式**，**减低了锁带来的性能消耗。

锁升级是为了减低了锁带来的性能消耗。

### 49. 什么是死锁？

当线程 A 持有独占锁a**，**并尝试去获取独占锁 b 的同时**，**线程 B 持有独占锁 b**，**并尝试获取独占锁 a 的情况**下****，**就会发生 AB 两个线程由于互相持有对方需要的锁**，**而发生的阻塞现象**，**我们称为死锁。

### 50. 怎么防止死锁？

- 尽量使用 tryLock(long timeout**,** TimeUnit unit)的方法(ReentrantLock、ReentrantReadWriteLock)**，**设置超时时间**，**超时可以退出防止死锁。
- 尽量使用 Java. util. concurrent 并发类代替自己手写锁。
- 尽量降低锁的使用粒度**，**尽量不要几个功能用同一把锁。
- 尽量减少同步的代码块。

### 51. ThreadLocal 是什么？有哪些使用场景？

ThreadLocal 为每个使用该变量的线程提供独立的变量副本**，**所以每一个线程都可以独立地改变自己的副本**，**而不会影响其它线程所对应的副本。

ThreadLocal 的经典使用场景是数据库连接和 session 管理等。

### 52. 说一**下** synchronized 底层实现原理？

synchronized 是由一对 monitorenter/monitorexit 指令实现的**，**monitor 对象是同步的基本实现单元。在 Java 6 之前**，**monitor 的实现完全是依靠操作系统内部的互斥锁**，**因为需要进行用户态到内核态的切换**，**所以同步操作是一个无差别的重量级操作**，**性能也很低。但在 Java 6 的时候**，**Java 虚拟机 对此进行了大刀阔斧地改进**，**提供了三种不同的 monitor 实现**，**也就是常说的三种不同的锁：偏向锁（Biased Locking）、轻量级锁和重量级锁**，**大大改进了其性能。

### 53. synchronized 和 volatile 的区别是什么？

- volatile 是变量修饰符；synchronized 是修饰类、方法、代码段。
- volatile 仅能实现变量的修改可见性**，**不能保证原子性；而 synchronized 则可以保证变量的修改可见性和原子性。
- volatile 不会造成线程的阻塞；synchronized 可能会造成线程的阻塞。

### 54. synchronized 和 Lock 有什么区别？

- synchronized 可以给类、方法、代码块加锁；而 lock 只能给代码块加锁。
- synchronized 不需要手动获取锁和释放锁**，**使用**简**单**，**发生异常会自动释放锁**，**不会造成死锁；而 lock 需要自己加锁和释放锁**，**如果使用不当没有 unLock()去释放锁就会造成死锁。
- 通过 Lock 可以知道有没有成功获取锁**，**而 synchronized 却无法办到。

### 55. synchronized 和 ReentrantLock 区别是什么？

synchronized 早期的实现比较低效**，**对比 ReentrantLock**，**大多数场景性能都相差较大**，**但是在 Java 6 中对 synchronized 进行了非常多的改进。

主要区别如**下**：

- ReentrantLock 使用起来比较灵活**，**但是必须有释放锁的配合动作；
- ReentrantLock 必须手动获取与释放锁**，**而 synchronized 不需要手动释放和开启锁；
- ReentrantLock 只适用于代码块锁**，**而 synchronized 可用于修饰方法、代码块等。
- volatile 标记的变量不会被编译器优化；synchronized 标记的变量可以被编译器优化。

### 56. 说一**下** atomic 的原理？

atomic 主要利用 CAS (Compare And Wwap) 和 volatile 和 native 方法来保证原子操作**，**从而避免 synchronized 的高开销**，**执行效率大为提升。

## 四、反射

### 57. 什么是反射？

反射是在运行状态中**，**对于任意一个类**，**都能够知道这个类的所有属性和方法；对于任意一个对象**，**都能够调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法的功能称为 Java 语言的反射机制。

### 58. 什么是 Java 序列化？什么情况**下**需要序列化？

Java 序列化是为了保存各种对象在内存中的状态**，**并且可以把保存的对象状态再读出来。

以**下**情况需要使用 Java 序列化：

- 想把的内存中的对象状态保存到一个文件中或者数据库中时候；
- 想用套接字在网络上传送对象的时候；
- 想通过RMI（远程方法调用）传输对象的时候。

### 59. 动态代理是什么？有哪些应用？

动态代理是运行时动态生成代理类。

动态代理的应用有 spring aop、hibernate 数据查询、测试框架的后端 mock、rpc**，**Java注解对象获取等。

\60. 怎么实现动态代理？

JDK 原生动态代理和 cglib 动态代理。JDK 原生动态代理是基于接口实现的**，**而 cglib 是基于继承当前类的子类实现的。

## 五、对象拷贝

### 61. 为什么要使用克隆？

克隆的对象可能包含一些已经修改过的属性**，**而 new 出来的对象的属性都还是初始化时候的值**，**所以当需要一个新的对象来保存当前对象的“状态”就靠克隆方法了。

### 62. 如何实现对象克隆？

- 实现 Cloneable 接口并重写 Object 类中的 clone() 方法。
- 实现 Serializable 接口**，**通过对象的序列化和反序列化实现克隆**，**可以实现真正的深度克隆。

### 63. 深拷贝和浅拷贝区别是什么？

- 浅克隆：当对象被复制时只复制它本身和其中包含的值类型的成员变量**，**而引用类型的成员对象并没有复制。
- 深克隆：除了对象本身被复制外**，**对象所包含的所有成员变量也将复制。

## 六、Java Web

### 64. JSP 和 servlet 有什么区别？

JSP 是 servlet 技术的扩展**，**本质上就是 servlet 的**简**易方式。servlet 和 JSP 最主要的不同点在于**，**servlet 的应用逻辑是在 Java 文件中**，**并且完全从表示层中的 html 里分离开来**，**而 JSP 的情况是 Java 和 html 可以组合成一个扩展名为 JSP 的文件。JSP 侧重于视图**，**servlet 主要用于控制逻辑。

### 65. JSP 有哪些内置对象？作用分别是什么？

JSP 有 9 大内置对象：

- request：封装客户端的请求**，**其中包含来自 get 或 post 请求的参数；
- response：封装服务器对客户端的响应；
- pageContext：通过该对象可以获取其他对象；
- session：封装用户会话的对象；
- application：封装服务器运行环境的对象；
- out：输出服务器响应的输出流对象；
- config：Web 应用的配置对象；
- page：JSP 页面本身（相当于 Java 程序中的 this）；
- exception：封装页面抛出异常的对象。

### 66. 说一**下** JSP 的 4 种作用域？

- page：代表与一个页面相关的对象和属性。
- request：代表与客户端发出的一个请求相关的对象和属性。一个请求可能跨越多个页面**，**涉及多个 Web 组件；需要在页面显示的临时数据可以置于此作用域。
- session：代表与某个用户与服务器建立的一次会话相关的对象和属性。跟某个用户相关的数据应该放在用户自己的 session 中。
- application：代表与整个 Web 应用程序相关的对象和属性**，**它实质上是跨越整个 Web 应用程序**，**包括多个页面、请求和会话的一个全局作用域。

### 67. session 和 cookie 有什么区别？

- 存储位置不同：session 存储在服务器端；cookie 存储在浏览器端。
- 安全性不同：cookie 安全性一般**，**在浏览器存储**，**可以被伪造和修改。
- 容量和个数限制：cookie 有容量限制**，**每个站点**下**的 cookie 也有个数限制。
- 存储的多样性：session 可以存储在 Redis 中、数据库中、应用程序中；而 cookie 只能存储在浏览器中。

### 68. 说一**下** session 的工作原理？

session 的工作原理是客户端登录完成之后**，**服务器会创建对应的 session**，**session 创建完之后**，**会把 session 的 id 发送给客户端**，**客户端再存储到浏览器中。这样客户端每次访问服务器时**，**都会带着 sessionid**，**服务器拿到 sessionid 之后**，**在内存找到与之对应的 session 这样就可以正常工作了。

### 69. 如果客户端禁止 cookie 能实现 session 还能用吗？

可以用**，**session 只是依赖 cookie 存储 sessionid**，**如果 cookie 被禁用了**，**可以使用 url 中添加 sessionid 的方式保证 session 能正常使用。

### 70. spring mvc 和 struts 的区别是什么？

- 拦截级别：struts2 是类级别的拦截；spring mvc 是方法级别的拦截。
- 数据独立性：spring mvc 的方法之间基本上独立的**，**独享 request 和 response 数据**，**请求数据通过参数获取**，**处理结果通过 ModelMap 交回给框架**，**方法之间不共享变量；而 struts2 虽然方法之间也是独立的**，**但其所有 action 变量是共享的**，**这不会影响程序运行**，**却给我们编码和读程序时带来了一定的麻烦。
- 拦截机制：struts2 有以自己的 interceptor 机制**，**spring mvc 用的是独立的 aop 方式**，**这样导致struts2 的配置文件量比 spring mvc 大。
- 对 ajax 的支持：spring mvc 集成了ajax**，**所有 ajax 使用很方便**，**只需要一个注解 @ResponseBody 就可以实现了；而 struts2 一般需要安装插件或者自己写代码才行。

### 71. 如何避免 SQL 注入？

- 使用预处理 PreparedStatement。
- 使用正则表达式过滤掉字符中的特殊字符。

### 72. 什么是 XSS 攻击**，**如何避免？

XSS 攻击：即跨站脚本攻击**，**它是 Web 程序中常见的漏洞。原理是攻击者往 Web 页面里插入恶意的脚本代码（css 代码、Javascript 代码等）**，**当用户浏览该页面时**，**嵌入其中的脚本代码会被执行**，**从而达到恶意攻击用户的目的**，**如盗取用户 cookie、破坏页面结构、重定向到其他网站等。

预防 XSS 的核心是必须对输入的数据做过滤处理。

### 73. 什么是 CSRF 攻击**，**如何避免？

CSRF：Cross-Site Request Forgery（中文：跨站请求伪造）**，**可以理解为攻击者盗用了你的身份**，**以你的名义发送恶意请求**，**比如：以你名义发送邮件、发消息、购买商品**，**虚拟货币转账等。

防御手段：

- 验证请求来源地址；
- 关键操作添加验证码；
- 在请求地址添加 token 并验证。

## 七、异常

### 74. throw 和 throws 的区别？

- throw：是真实抛出一个异常。
- throws：是声明可能会抛出一个异常。

### 75. final、finally、finalize 有什么区别？

- final：是修饰符**，**如果修饰类**，**此类不能被继承；如果修饰方法和变量**，**则表示此方法和此变量不能在被改变**，**只能使用。
- finally：是 try{} catch{} finally{} 最后一部分**，**表示不论发生任何情况都会执行**，**finally 部分可以省略**，**但如果 finally 部分存在**，**则一定会执行 finally 里面的代码。
- finalize： 是 Object 类的一个方法**，**在垃圾收集器执行的时候会调用被回收对象的此方法。

### 76. try-catch-finally 中哪个部分可以省略？

try-catch-finally 其中 catch 和 finally 都可以被省略**，**但是不能同时省略**，**也就是说有 try 的时候**，**必须后面跟一个 catch 或者 finally。

### 77. try-catch-finally 中**，**如果 catch 中 return 了**，**finally 还会执行吗？

finally 一定会执行**，**即使是 catch 中 return 了**，**catch 中的 return 会等 finally 中的代码执行完之后**，**才会执行。

### 78. 常见的异常类有哪些？

- NullPointerException 空指针异常
- ClassNotFoundException 指定类不存在
- NumberFormatException 字符串转换为数字异常
- IndexOutOfBoundsException 数组**下**标越界异常
- ClassCastException 数据类型转换异常
- FileNotFoundException 文件未找到异常
- NoSuchMethodException 方法不存在异常
- IOException IO 异常
- SocketException Socket 异常

## 八、网络

### 79. http 响应码 301 和 302 代表的是什么？有什么区别？

301：永久重定向。

302：暂时重定向。

它们的区别是**，**301 对搜索引擎优化（SEO）更加有利；302 有被提示为网络拦截的风险。

### 80. forward 和 redirect 的区别？

forward 是转发 和 redirect 是重定向：

- 地址栏 url 显示：foward url 不会发生改变**，**redirect url 会发生改变；
- 数据共享：forward 可以共享 request 里的数据**，**redirect 不能共享；
- 效率：forward 比 redirect 效率高。

### 81. **简**述 tcp 和 udp的区别？

tcp 和 udp 是 OSI 模型中的运输层中的协议。tcp 提供可靠的通信传输**，**而 udp 则常被用于让广播和细节控制交给应用的通信传输。

两者的区别大致如**下**：

- tcp 面向连接**，**udp 面向非连接即发送数据前不需要建立链接；
- tcp 提供可靠的服务（数据传输）**，**udp 无法保证；
- tcp 面向字节流**，**udp 面向报文；
- tcp 数据传输慢**，**udp 数据传输快；

### 82. tcp 为什么要三次握手**，**两次不行吗？为什么？

如果采用两次握手**，**那么只要服务器发出确认数据包就会建立连接**，**但由于客户端此时并未响应服务器端的请求**，**那此时服务器端就会一直在等待客户端**，**这样服务器端就白白浪费了一定的资源。若采用三次握手**，**服务器端没有收到来自客户端的再此确认**，**则就会知道客户端并没有要求建立请求**，**就不会浪费服务器的资源。

### 83. 说一**下** tcp 粘包是怎么产生的？

tcp 粘包可能发生在发送端或者接收端**，**分别来看两端各种产生粘包的原因：

- 发送端粘包：发送端需要等缓冲区满才发送出去**，**造成粘包；
- 接收方粘包：接收方不及时接收缓冲区的包**，**造成多个包接收。

### 84. OSI 的七层模型都有哪些？

- 物理层：利用传输介质为数据链路层提供物理连接**，**实现比特流的透明传输。
- 数据链路层：负责建立和管理节点间的链路。
- 网络层：通过路由选择算法**，**为报文或分组通过通信子网选择最适当的路径。
- 传输层：向用户提供可靠的端到端的差错和流量控制**，**保证报文的正确传输。
- 会话层：向两个实体的表示层提供建立和使用连接的方法。
- 表示层：处理用户信息的表示问题**，**如编码、数据格式转换和加密解密等。
- 应用层：直接向用户提供服务**，**完成用户希望在网络上完成的各种工作。

### 85. get 和 post 请求有哪些区别？

- get 请求会被浏览器主动缓存**，**而 post 不会。
- get 传递参数有大小限制**，**而 post 没有。
- post 参数传输更安全**，**get 的参数会明文限制在 url 上**，**post 不会。

### 86. 如何实现跨域？

实现跨域有以**下**几种方案：

- 服务器端运行跨域 设置 CORS 等于 *；
- 在单个接口使用注解 @CrossOrigin 运行跨域；
- 使用 jsonp 跨域；

### 87. 说一**下** JSONP 实现原理？

jsonp：JSON with Padding**，**它是利用script标签的 src 连接可以访问不同源的特性**，**加载远程返回的“JS 函数”来执行的。

### 九、设计模式

### 88. 说一**下**你熟悉的设计模式？

- 单例模式：保证被创建一次，节省系统开销。
- 工厂模式（简单工厂、抽象工厂）：解耦代码。
- 观察者模式：定义了对象之间的一对多的依赖，这样一来，当一个对象改变时，它的所有的依赖者都会收到通知并自动更新。
- 外观模式：提供一个统一的接口，用来访问子系统中的一群接口，外观定义了一个高层的接口，让子系统更容易使用。
- 模版方法模式：定义了一个算法的骨架，而将一些步骤延迟到子类中，模版方法使得子类可以在不改变算法结构的情况下，重新定义算法的步骤。
- 状态模式：允许对象在内部状态改变时改变它的行为，对象看起来好像修改了它的类。

### 89. **简**单工厂和抽象工厂有什么区别？

- 简单工厂：用来生产同一等级结构中的任意产品**，**对于增加新的产品**，**无能为力。
- 工厂方法：用来生产同一等级结构中的固定产品**，**支持增加任意产品。
- 抽象工厂：用来生产不同产品族的全部产品**，**对于增加新的产品**，**无能为力；支持增加产品族。















